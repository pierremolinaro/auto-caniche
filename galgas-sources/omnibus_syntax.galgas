syntax omnibus_syntax (lexicalAnalyzer) {

#--------------------------------------------------------------------*

rule <start_symbol>
  !@ast outAST {
  outAST = @ast.default
  repeat
  while 
    <enum_declaration> !?outAST
  while 
    <enum_function> !?outAST
  while 
    <machine> !?outAST
  while 
    <scenario> !?outAST
  end
}

#--------------------------------------------------------------------*

rule <scenario>
  ?!@ast ioAST {
  $scenario$
  $machine-type-name$ ?var @lstring machineTypeName
  $literal_string$ ?var @lstring scenarioName
  $:$
  var eventSequence =@scenarioEventSequence.default
  repeat
    $identifier$ ?var  @lstring eventName
    var argList =@lstringlist.emptyList{}
    repeat
    while
      $!$
      $identifier$ ?var  @lstring argName
      argList += !argName
    end
    eventSequence += !eventName !argList
  while
    $,$
  end
  $;$
  ioAST.mScenarioList += !machineTypeName !scenarioName !eventSequence
}

#--------------------------------------------------------------------*

rule <enum_declaration>
  ?!@ast ioAST {
  $enum$
  $enum-type-name$ ?var @lstring enumName
  ${$
  var cstList =@lstringlist.emptyList{}
  repeat
    $identifier$ ?var  @lstring constantName
    cstList += !constantName
  while
    $,$
  end
  $}$
  ioAST.mEnumTypeList += !enumName !cstList
}

#--------------------------------------------------------------------*

rule <enum_function>
  ?!@ast ioAST {
  $function$
  $identifier$ ?var  @lstring functionName
  $enum-type-name$ ?var @lstring operandEnumName
  $->$
  $enum-type-name$ ?var @lstring resultEnumName
  var functionValueList = @functionValueList.default
  repeat
    $identifier$ ?var  @lstring operandConstantName
    $:$
    $identifier$ ?var  @lstring resultConstantName
    functionValueList += !operandConstantName !resultConstantName
  while
  end
  $}$
  ioAST.mFunctionDefinitionList += !functionName !operandEnumName !resultEnumName !functionValueList
}

#--------------------------------------------------------------------*

rule <machine> ?!@ast ioAST {
  $machine$
  $machine-type-name$ ?var @lstring machineTypeName
#---
  var invariantExpressionList =@expressionList.emptyList{}
  var enumVarDeclarationList =@enumVarDeclarationList.default
  var eventList =@eventDeclarationList.default
  repeat
  while
    $var$
    $identifier$ ?var  @lstring variableName
    $enum-type-name$ ?var @lstring enumTypeName
    $=$
    $.$
    $identifier$ ?var  @lstring constantName
    enumVarDeclarationList += !enumTypeName !variableName !constantName
   while
    $invariant$
    $literal_string$ ?var @lstring lbl
    $:$
    <expression> ?let @expression expression
    invariantExpressionList += !lbl !expression
  while
    $event$
    $identifier$ ?var  @lstring eventName
    $($
    var eventArgumentList =@eventArgumentList.default
    repeat
    while
      $?$
      $identifier$ ?var  @lstring argumentName
      $enum-type-name$ ?var @lstring enumTypeName
      eventArgumentList += !enumTypeName !argumentName
    end
    $)$   
    ${$
    @instructionList eventInstructionList = {}
    <instruction_list> !?eventInstructionList
    var ensureExpressionList =@expressionList.default
    select
    or
      $ensures$
      repeat
        $literal_string$ ?var @lstring lbl
        $:$
        <expression> ?let @expression expression
        ensureExpressionList += !lbl !expression
      while
      end
    end
    @location endOfEnsureExpressionList = @location.here
    $}$
    eventList +=
      !eventName
      !eventArgumentList
      !eventInstructionList
      !ensureExpressionList
      !endOfEnsureExpressionList
  end
#---
  $}$
  ioAST.mMachineList +=
    !machineTypeName
    !enumVarDeclarationList
    !invariantExpressionList
    !eventList
}

#--------------------------------------------------------------------*

rule <expression> !@expression outExpression {
  <expression1> ?outExpression
  select
  or
    $->$
    <expression1> ?let @expression expr
    outExpression = @implicationExpression. new { !outExpression !expr}
  end
}

#--------------------------------------------------------------------*

rule <expression1> !@expression outExpression {
  <expression2> ?outExpression
  repeat
  while
    $|$
    <expression2> ?let @expression expr
    outExpression = @logicalOrExpression. new { !outExpression !expr}
  end
}

#--------------------------------------------------------------------*

rule <expression2> !@expression outExpression {
  <expression4> ?outExpression
  repeat
  while
    $&$
    <expression4> ?let @expression expr
    outExpression = @logicalAndExpression. new { !outExpression !expr}
  end
}

#--------------------------------------------------------------------*

rule <expression4> !@expression outExpression {
  $($
  <expression> ?outExpression
  $)$
}

#--------------------------------------------------------------------*

rule <expression4> !@expression outExpression {
  $identifier$ ?var  @lstring attributeName
  @enumComparisonOperator comparisonOperator
  select
    $==$
    comparisonOperator = @enumComparisonOperator.equal
  or
    $!=$
    comparisonOperator = @enumComparisonOperator.notEqual
  end
  <comparison_right_operand> ?let @comparisonRightOperand comparisonRightOperand
  outExpression = @comparisonInExpression. new {
    !attributeName
    !comparisonOperator
    !comparisonRightOperand}
}

#--------------------------------------------------------------------*

rule <comparison_right_operand> !@comparisonRightOperand outComparisonRightOperand {
  $.$
  $identifier$ ?var  @lstring constantName
  outComparisonRightOperand = @constantAsComparisonRightOperand. new {
    !constantName}
}

#--------------------------------------------------------------------*

rule <comparison_right_operand> !@comparisonRightOperand outComparisonRightOperand {
  @bool hasOldQualifier
  select
    hasOldQualifier = false
  or
    $old$
    hasOldQualifier = true
  end
  $identifier$ ?var  @lstring attributeName
  outComparisonRightOperand = @attributeAsComparisonRightOperand. new {
    !attributeName
    !hasOldQualifier}
}

#--------------------------------------------------------------------*

rule <instruction_list> ?!@instructionList ioInstructionList {
  repeat
  while
    <instruction> ?let @instruction instruction
    ioInstructionList += !instruction
  end
}

#--------------------------------------------------------------------*

rule <instruction> !@instruction outInstruction {
  $assert$
  let @location instructionLocation = @location.here
  <expression> ?let @expression assertExpression
  outInstruction = @assertInstruction. new { !instructionLocation !assertExpression}
}

#--------------------------------------------------------------------*

rule <instruction> !@instruction outInstruction {
  $identifier$ ?var  @lstring variableName
  $=$
  <assignment_source_expression> ?let @assignmentSourceExpression expression
  outInstruction = @assignmentInstruction. new { !variableName !expression}
}

#--------------------------------------------------------------------*

rule <assignment_source_expression> !@assignmentSourceExpression outExp {
  $identifier$ ?var  @lstring attributeName
  outExp = @varAsAssignmentSourceExpression. new { !attributeName}
}

#--------------------------------------------------------------------*

rule <assignment_source_expression> !@assignmentSourceExpression outExp {
  $.$
  $identifier$ ?var  @lstring constantName
  outExp = @constantAsAssignmentSourceExpression. new { !constantName}
}

#--------------------------------------------------------------------*

rule <assignment_source_expression> !@assignmentSourceExpression outExp {
  $identifier$ ?var  @lstring functionName
  $($
  $identifier$ ?var  @lstring attributeName
  $)$
  outExp = @functionAsAssignmentSourceExpression. new { !functionName !attributeName}
}

#--------------------------------------------------------------------*

rule <instruction> !@instruction outInstruction {
  $if$
  let @location IFinstructionLocation = @location.here
  <expression> ?let @expression testExpression
  let @location endOfTestExpression = @location.here
  ${$
  @instructionList thenInstructionList = {}
  <instruction_list> !?thenInstructionList
  $}$
  <else_part> ?let @instructionList elseInstructionList
  outInstruction = @ifInstruction. new {
    !IFinstructionLocation
    !testExpression
    !endOfTestExpression
    !thenInstructionList
    !elseInstructionList}
}

#--------------------------------------------------------------------*

rule <else_part> !@instructionList outInstructionList {
  outInstructionList = {}
}

#--------------------------------------------------------------------*

rule <else_part> !@instructionList outInstructionList {
  $else$
  ${$
  outInstructionList = {}
  <instruction_list> !?outInstructionList
  $}$
}

#--------------------------------------------------------------------*

rule <else_part> !@instructionList outInstructionList {
  $else$
  $if$
  let @location IFinstructionLocation = @location.here
  <expression> ?let @expression testExpression
  let @location endOfTestExpression = @location.here
  ${$
  @instructionList thenInstructionList = {}
  <instruction_list> !?thenInstructionList
  $}$
  <else_part> ?let @instructionList elseInstructionList
  outInstructionList = {}
  outInstructionList += !@ifInstruction. new { 
    !IFinstructionLocation
    !testExpression
    !endOfTestExpression
    !thenInstructionList
    !elseInstructionList}
}

#--------------------------------------------------------------------*

}